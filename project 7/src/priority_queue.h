#ifndef PRIORITY_QUEUE_H_
#define PRIORITY_QUEUE_H_

template<typename T, typename Comparator = std::less<T>>
class PriorityQueue {

public:
    /**
     * Конструктор очереди по умолчанию
     */
    PriorityQueue() : _binHeap(0) {};

    /**
     * Параметризованный конструктор
     * @param n - число элементов в очереди
     */
    PriorityQueue(size_t n) { _binHeap.reserve(n); };

public:
    /**
     * метод помещает новый элемент в очередь
     * @param newElement элемент, который будет помещен
     */
    void push(const T& newElement)
    {
        _binHeap.push_back(newElement);
        siftUp(size() - 1);
    }

    /**
     * метод извлекает элемент из начала очереди (в соответствии с определенным компаратором)
     * @return элемент из начала очереди
     */
    T pop()
    {
        if (isEmpty())
            throw std::out_of_range("PriorityQueue is empty!");

        T temp = _binHeap[0];

        _binHeap[0] = _binHeap[size() - 1]; //передвигаем последний элемент в корень
        _binHeap.pop_back();
        siftDown(0);

        return temp;
    }

    /**
     * метод получает элемент из начала очереди (не удаляя его из самой очереди)
     * @return элемент из начала очереди
     */
    T top()
    {
        if (isEmpty())
            throw std::out_of_range("PriorityQueue is empty");

        return _binHeap[0];
    }



    /**
     * метод возвращает размер очереди
     * @return число элементов в очереди
     */
    size_t size() const
    {
        return _binHeap.size();
    }

    /**
     *
     * @return true - если в очереди нет элементов, иначе - false
     */
    bool isEmpty()
    {
        return _binHeap.size() == 0;
    }

    /**
     *
     * @return true - если достигнут максимальный размер очереди, иначе - false
     */
    bool isFull()
    {
        return false;
    }


    /**
     * Метод упорядочивает кучу (применять если объекты были изменены напрямую, напр. через указатель)
     */
    void heapify()
    {
        for (int i = size() / 2; i >= 0; --i)
            siftDown(i);
    }

private:
    /**
     * Вспомогательный метод для смещения объекта вниз по дереву
     * @param i индекс объекта в векторе
     */
    void siftDown(int i)
    {
        while (i * 2 + 1 < size())
        {
            int leftChild = i * 2 + 1;  //индекс левого потомка
            int rightChild = i * 2 + 2; //индекс правого потомка
            int swapIndex = leftChild;  //индекс элемента, с которым производится обмен

            //если правый потомок должен быть выше левого потомка
            //индекс потомка для обмена равен индексу правого потомка
            if (rightChild < _binHeap.size() && comparator(_binHeap[rightChild], _binHeap[swapIndex]))
                swapIndex = rightChild;

            //если оба потомка должны стоять ниже выходим из цикла
            if (comparator(_binHeap[i], _binHeap[swapIndex]))
                break;

            //обмен элементов дерева
            T temp = _binHeap[i];
            _binHeap[i] = _binHeap[swapIndex];
            _binHeap[swapIndex] = temp;

            i = swapIndex;  //теперь индекс смещаемого элемента равен swapIndex
        }
    }

    /**
     * Вспомогательный метод для смещения объекта вверх по дереву
     * @param i индекс смещаемого объекта в векторе
     */
    void siftUp(int i)
    {
        while (comparator(_binHeap[i], _binHeap[(i - 1) / 2]))
        {
            T temp = _binHeap[i];
            _binHeap[i] = _binHeap[(i - 1) / 2];
            _binHeap[(i - 1) / 2] = temp;

            i = (i - 1) / 2;
        }
    }

    /**
     * Контейнер для элементов очереди
     */
    std::vector<T> _binHeap;

    /**
     * Компаратор определяющий порядок объектов в очереди
     */
    Comparator comparator;
};

// TODO: Напишите здесь СОБСТВЕННУЮ реализацию шаблонного класса PriorityQueue (название д.б. строго таким!) — 
// очередь с приоритетами, удовлетворяющего следующему концепту:
//
//1)  Шаблон определения очереди должен быть строго представлен в настояем файле `priority_queue.h` полностью без разделения на h/hpp;
//    определение — в глобальном пространстве имен.
//
//2)  Шаблон имеет два параметра: <T> определяет тип элементов, хранящихся в очереди; <Comparator> задает тип (для создания 
//    объекта-компаратора) для сравнения элементов для получения порядка, по умолчанию 
//    Comparator = std::less<typename T>.
//   
//3)  Шаблон определяет следующие основные операции над очередью:

//    а)  Помещение нового элемента в очередь:
//        void push(const T& newElement);
//        Способ реорганизации/переупорядочивания очереди (ленивый/отложенный или немедленный) определяется самостоятельно.
//        Если конкретная (ваша) реализация очереди подразумевает максимальный размер, то при превышении (помещением очередного
//        элемента) максимального размера, генерируется исключение std::out_of_range.
//        
//    б)  Извлечение "максимального" элемента из начала очереди (в соответствии с порядком, определяемым компаратором):
//        T pop();
//        Если очередь пуста, генерируется исключение std::out_of_range.
//        
//    в)  Получение "максимального" элемента из начала очереди без удаления его из очереди:
//        T top();
//        Если очередь пуста, генерируется исключение std::out_of_range.
//
//    г)  Получение размера очереди:
//        size_t size() const;
//        
//    д)  Определения, является ли очередь пустой; является ли очередь заполненной:
//        bool isEmpty() const;
//        bool isFull() const;
//        Если реализация не подразумевает ограничение на число хранимых в очереди элементов,
//        метод isFull() всегда возвращает false.
//    
//    е)  Конструкторы: по умолчанию, инициализация размером очереди (если известен). Деструктор, если нужен, КК и ОП для соответствия
//        правило большой тройки (если применимо).
//        
//4)  Шаблон реализации класса определяется самостоятельно. Тестирование будет осуществляться на предмет соответствия указанному 
//    концепту. Также при review кода будет приниматься во внимания особенно важные имлементационные моменты.
//    Выбор подлежащей структуры (вектор, лист, куча, дерева...) на оценку большого влияния не окажет.
//    Проксирование (использование стандартного контейнера std::priority_queue) не разрешено.
//
//5)  При необходимости можно доопределить вспомогательные классы внутри шаблона очереди или вне его. При этом
//    их определение не должно влечь за собой дополнительных ограничений на использование типа
//    PriorityQueue<T, Comparator> за пределами данного модуля.
//
//6)  При желании можно реализовать итератор(ы) для перебора элементов очереди в порядке, определяемом компаратором.
//    В этом случае следует дополнить семантику класса соответствующими методами: begin(), end() и т.д.

#endif // 
